# Week4 Report

Used hours: 24h

### What I did
- I fiexed some bugs of the A*-algorithm which I implemented last week. In my A*-algoithm, the nodes which were added into the IndexPriorityQueue should also be saved in the HashMap, where the key is the node and the value is the index of the node. If the algorithm ran in the right way, the nodes which were saved to the HashMap should also be able to be found in the IndexPriorityQueue. However, in the old version of my A*-algorithm, the nodes which were seem to be saved to the HashMap couldn't be found in the IndexPriorityQueue by its index in some cases. I spent a long time debugging my algorithm and realized that the problem was caused by that when a node was polled from the IndexPriorityQueue, it wasn't removed from the HashMap. 

- I generated some of my own data structures which are ArrayList, queue and RandomQueue. The mos interesting data structure is the RandomQueue used when generating graph by DFS, where an element can be added both to the begin of the queue and to the end of the queue depending the random number that has been generated. If the generated random number is odd, the element will be added to the begin of the queue and if the generated random number is even, the element will be added to the end of the queue. Also the Random queue can also poll its first or last element depending on the generated random number.

- I refactored my A*-algorithm. I generated the A*-algorithm using different heuristic functions and I refactored them to remove many repeated codes.

- I used DFS to generate the labyrinth. The labyrinth generated by DFS has longer corridors and less branching factors compared to the labyrinth generated by randomized Prim. This influences the performance of path finding algorithms.

- I started performance evaluation.

### What I learnt
- I learnt that graphs generated by different algorithms may have different features. Some of them may have long corridors while others of them may be biased towards many short dead ends.

- I also learnt how the heuristic function may affect the efficiency and the result of A*-algorithm.

### What I'm going to do
- I'm going to continue the performance evaluation and show the results of the performance evaluation in graphs and tables if it's possible.

- I'll implement the rest of data structures which are HashMap and HashSet.

### Some Problems
- I've learnt that in Java8 the HashMap uses linked list in the beginning, and when collisions are getting more it uses binary tree. I tried to implement the HashMap using TreeMap but it just caused problems when running algorithms. I guess the reason of this problem is that HashMap uses equals and TreeMap compareTo to define whether two elements are same. I'm using HashMap to save my own object Node, where both equals- and compareTo-methods have been overridden. Maybe I need to check these two methods again. 
